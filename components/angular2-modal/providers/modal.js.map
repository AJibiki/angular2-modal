{"version":3,"file":"modal.js","sourceRoot":"","sources":["modal.ts"],"names":[],"mappings":";;;;;;AAAA,qBAIO,eAAe,CAAC,CAAA;AAKvB,2BAA0B,sBAAsB,CAAC,CAAA;AAGjD;IAA4C,0CAAK;IAC/C,gCAAY,UAAkB;QAC5B,iBAAO,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,yBAAuB,UAAY,CAAC;IACrD,CAAC;IACH,6BAAC;AAAD,CAAC,AALD,CAA4C,KAAK,GAKhD;AALY,8BAAsB,yBAKlC,CAAA;AAED;IACE,eAAmB,OAAgB;QAAhB,YAAO,GAAP,OAAO,CAAS;IAAI,CAAC;IAGxC,qBAAK,GAAL;QACE,MAAM,IAAI,sBAAsB,CAAC,OAAO,CAAC,CAAC;IAC5C,CAAC;IAED,sBAAM,GAAN;QACE,MAAM,IAAI,sBAAsB,CAAC,QAAQ,CAAC,CAAC;IAC7C,CAAC;IAED,uBAAO,GAAP;QACE,MAAM,IAAI,sBAAsB,CAAC,SAAS,CAAC,CAAC;IAC9C,CAAC;IAED;;;;;OAKG;IACH,oBAAI,GAAJ,UAAK,aAAkB,EAAE,MAAsB;QAC7C,MAAM,GAAG,MAAM,IAAI,EAAS,CAAC;QAC7B,IAAI,CAAC;YACH,IAAI,OAAO,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YAExC,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBACvB,OAAO,CAAC,IAAI,CAAC,oKAE8B,CAAC,CAAC;YAC/C,CAAC;YACD,6EAA6E;YAC7E,yCAAyC;YACzC,MAAM,CAAC,OAAO,CAAC,OAAO,CACpB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,aAAa,EAAE,MAAM,CAAC,QAAQ,CAAC,CACxD,CAAC;QAEJ,CAAE;QAAA,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;YACX,MAAM,CAAC,OAAO,CAAC,MAAM,CAAiB,CAAC,CAAC,CAAC;QAC3C,CAAC;IAEH,CAAC;IAcD;;;;;;OAMG;IACO,2BAAW,GAArB,UAA4B,SAAyB,EAAE,QAAkB,EAAE,SAAmB;QAE5F,IAAM,CAAC,GAAG,yBAAkB,CAAC,OAAO,CAAC,CAAC,EAAC,OAAO,EAAE,sBAAS,EAAE,QAAQ,EAAE,SAAS,EAAC,CAAC,CAAC,CAAC;QAElF,MAAM,CAAC;YACL,WAAW,EAAE,SAAS,CAAC,UAAU,CAAC,QAAQ,CAAC,YAAY,CAAI,QAAQ,EAAE,CAAC,CAAC;YACvE,YAAY,EAAE,SAAS,CAAC,UAAU,CAAC,QAAQ,CAAC,YAAY,CAAI,SAAS,EAAE,CAAC,CAAC;SAC1E,CAAC;IACJ,CAAC;IAEH,YAAC;AAAD,CAAC,AAzED,IAyEC;AAzEqB,aAAK,QAyE1B,CAAA","sourcesContent":["import {\n  ComponentRef,\n  ReflectiveInjector,\n  ResolvedReflectiveProvider\n} from '@angular/core';\n\nimport { Overlay } from '../overlay';\nimport { Class, Maybe } from '../framework/utils';\nimport { OverlayConfig } from '../models/tokens';\nimport { DialogRef } from '../models/dialog-ref';\nimport { ModalControllingContextBuilder } from '../models/overlay-context';\n\nexport class UnsupportedDropInError extends Error {\n  constructor(dropInName: string) {\n    super();\n    this.message = `Unsupported Drop-In ${dropInName}`;\n  }\n}\n\nexport abstract class Modal {\n  constructor(public overlay: Overlay) { }\n\n\n  alert(): ModalControllingContextBuilder<any> {\n    throw new UnsupportedDropInError('alert');\n  }\n\n  prompt(): ModalControllingContextBuilder<any> {\n    throw new UnsupportedDropInError('prompt');\n  }\n\n  confirm(): ModalControllingContextBuilder<any> {\n    throw new UnsupportedDropInError('confirm');\n  }\n\n  /**\n   * Opens a modal window inside an existing component.\n   * @param componentType The angular Component to render as the modal content.\n   * @param config Additional settings.\n   * @returns {Promise<DialogRef>}\n   */\n  open(componentType: any, config?: OverlayConfig): Promise<DialogRef<any>> {\n    config = config || {} as any;\n    try {\n      let dialogs = this.overlay.open(config);\n\n      if (dialogs.length > 1) {\n        console.warn(`Attempt to open more then 1 overlay detected.\n        Multiple modal copies are not supported at the moment, \n        only the first viewContainer will display.`);\n      }\n      // TODO:  Currently supporting 1 view container, hence working on dialogs[0].\n      //        upgrade to multiple containers.\n      return Promise.resolve(\n        this.create(dialogs[0], componentType, config.bindings)\n      );\n\n    } catch (e) {\n      return Promise.reject<DialogRef<any>>(e);\n    }\n\n  }\n\n  /**\n   * A Hook that enables derived classes to add content to the overlay.\n   * @param dialogRef\n   * @param type\n   * @param bindings\n   * @returns {MaybeDialogRef<any>}\n   */\n  protected abstract create(dialogRef: DialogRef<any>,\n                            type: any,\n                            bindings?: ResolvedReflectiveProvider[]): Maybe<DialogRef<any>>;\n\n\n  /**\n   * A helper function for derived classes to create backdrop & container\n   * @param dialogRef\n   * @param backdrop\n   * @param container\n   * @returns { backdropRef: ComponentRef<B>, containerRef: ComponentRef<C> }\n   */\n  protected createModal<B, C>(dialogRef: DialogRef<any>, backdrop: Class<B>, container: Class<C>)\n                                : { backdropRef: ComponentRef<B>, containerRef: ComponentRef<C> } {\n    const b = ReflectiveInjector.resolve([{provide: DialogRef, useValue: dialogRef}]);\n\n    return {\n      backdropRef: dialogRef.overlayRef.instance.addComponent<B>(backdrop, b),\n      containerRef: dialogRef.overlayRef.instance.addComponent<C>(container, b)\n    };\n  }\n\n}\n"]}